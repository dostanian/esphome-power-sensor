# ESPHome power-sensor
This project contains the "source code" discussed in the YouTube video by the same name.

# Parts List

- Microcontroller
  - ESP32 dev module
    - C3 Super Mini (with antenna mod)
    - [AliExpress Link](https://www.aliexpress.com/item/1005009014269977.html)
  - [Esp32 C3 Super Mini Antenna Mod](https://peterneufeld.wordpress.com/2025/03/04/esp32-c3-supermini-antenna-modification)
- Meter
  - PZEM-004T V3.0
    - UART communication
    - [AliExpress Link](https://www.aliexpress.com/item/1005004314523358.html)
- Display
  - 20x4 2004 LCD Display Module with I2C Adaptor
    - I2C communication bus
    - [AliExpress Link](https://www.aliexpress.com/item/1005007046647456.html)
- Power supply
  - LDE05-20B05
  - Any PSU that can supply at least 250mA at 5V will do
- Logic Level Shifter
  - BSS138 based open collector style
    - Safely converts 3v3 signals from the Esp32 to the peripherals and back
    - [AliExpress Link](https://www.aliexpress.com/item/1005006765742290.html)

# ESPHome configuration

```yaml
esphome:
  name: power-sensor
  friendly_name: power-sensor

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: esp-idf

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: "*autogenerated by esphome when adding new sensor*"
  reboot_timeout: 15min

ota:
  - platform: esphome
    password: "*autogenerated by esphome when adding new sensor*"

safe_mode:

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Improve WiFi stability
  power_save_mode: none
  fast_connect: true
  reboot_timeout: 15min
  output_power: 8.5dB  # 20dB = Maximum WiFi transmit power

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Power-Sensor-2 Fallback Hotspot"
    password: "*autogenerated by esphome when adding new sensor*"

captive_portal:

i2c:
  sda: GPIO8
  scl: GPIO9

uart:
  id: uart_bus
  rx_pin: GPIO20
  tx_pin: GPIO21
  baud_rate: 9600
  data_bits: 8
  stop_bits: 1
  parity: NONE

modbus:
  id: modbus1
  uart_id: uart_bus
  send_wait_time: 200ms

modbus_controller:
  - id: pzem
    address: 0x1
    modbus_id: modbus1
    setup_priority: -10
    command_throttle: 200ms  # Increased from 100ms for stability
    update_interval: 60s  # Reduced frequency to lower load

sensor:
  - platform: modbus_controller
    modbus_controller_id: pzem
    name: "PZEM Voltage"
    id: pzem_voltage
    register_type: read  # Changed from holding
    address: 0x0000
    unit_of_measurement: "V"
    device_class: voltage
    value_type: U_WORD
    register_count: 1
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: pzem
    name: "PZEM Current"
    id: pzem_current
    register_type: read
    address: 0x0001
    unit_of_measurement: "A"
    device_class: current
    value_type: U_DWORD_R
    register_count: 2
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  - platform: modbus_controller
    modbus_controller_id: pzem
    name: "PZEM Power"
    id: pzem_power
    register_type: read
    address: 0x0003
    unit_of_measurement: "W"
    device_class: power
    value_type: U_DWORD_R
    register_count: 2
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: pzem
    name: "PZEM Energy"
    id: pzem_energy
    register_type: read
    address: 0x0005
    unit_of_measurement: "kWh"
    device_class: energy
    value_type: U_DWORD_R
    register_count: 2
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  - platform: modbus_controller
    modbus_controller_id: pzem
    name: "PZEM Frequency"
    id: pzem_freq
    register_type: read
    address: 0x0007
    unit_of_measurement: "Hz"
    value_type: U_WORD
    register_count: 1
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: pzem
    name: "PZEM Power Factor"
    id: pzem_pf
    register_type: read
    address: 0x0008
    unit_of_measurement: ""
    value_type: U_WORD
    register_count: 1
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

# Physical button (optional)
binary_sensor:
  - platform: gpio
    pin:
      number: GPIO2
      mode:
        input: true
        pullup: true  # Pulls pin HIGH when button not pressed
      inverted: true  # Button pulls LOW when pressed
    name: "LCD Button"
    filters:
      - delayed_on: 50ms  # Debounce - recommended!
      - delayed_off: 50ms
    on_press:
      - logger.log: "Button pressed!"
      - switch.turn_on: lcd_backlight_switch
    on_release:
      - logger.log: "Button released!"

switch:
  - platform: template
    name: "LCD Backlight"
    id: lcd_backlight_switch
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    turn_on_action:
      - logger.log: "Backlight turn ON"
      - lambda: |-
          id(my_display).backlight();
      - script.execute: backlight_auto_off
    turn_off_action:
      - logger.log: "Backlight turn OFF"
      - script.stop: backlight_auto_off
      - lambda: |-
          id(my_display).no_backlight();

script:
  - id: backlight_auto_off
    mode: restart
    then:
      - delay: 20s
      - logger.log: "Auto-turning off backlight"
      - switch.turn_off: lcd_backlight_switch

display:
  - platform: lcd_pcf8574
    dimensions: 20x4
    address: 0x27
    id: my_display
    update_interval: 30s  # Reduced to lower I2C/CPU load
    lambda: |-
      // Optimized display - direct printf without nested str_sprintf
      if (!isnan(id(pzem_voltage).state) && !isnan(id(pzem_freq).state)) {
        it.printf(0, 0, "V:%.1fV F:%.1fHz", id(pzem_voltage).state, id(pzem_freq).state);
      } else {
        it.print(0, 0, "V:--- F:---");
      }

      if (!isnan(id(pzem_current).state) && !isnan(id(pzem_pf).state)) {
        it.printf(0, 1, "I:%.2fA PF:%.2f", id(pzem_current).state, id(pzem_pf).state);
      } else {
        it.print(0, 1, "I:--- PF:---");
      }

      if (!isnan(id(pzem_power).state)) {
        it.printf(0, 2, "P:%.1fW", id(pzem_power).state);
      } else {
        it.print(0, 2, "P:---");
      }

      if (!isnan(id(pzem_energy).state)) {
        it.printf(0, 3, "E:%.1fkWh", id(pzem_energy).state);
      } else {
        it.print(0, 3, "E:---");
      }

```

# Wiring diagram

A partial wiring diagram is given in a file called "Wiring Diagram.png"

__Note:__ The diagram actually shows only the actual Esp32 C3 chip not the module. 
The 5V power source is wired to the 5V pin of the Esp32.
The Esp32 module has its own LDO regulator to convert 5V to 3V3 for the chip.